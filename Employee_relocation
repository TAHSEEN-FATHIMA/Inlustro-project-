import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from scipy.optimize import linear_sum_assignment
from sklearn.metrics import classification_report

# Step 1: Generate synthetic employee data
np.random.seed(42)
num_employees = 100
data = pd.DataFrame({
    'EmployeeID': range(1, num_employees + 1),
    'Age': np.random.randint(22, 60, size=num_employees),
    'Department': np.random.choice(['Sales', 'IT', 'HR', 'Finance'], size=num_employees),
    'YearsAtCompany': np.random.randint(1, 20, size=num_employees),
    'PerformanceRating': np.random.choice([1, 2, 3, 4, 5], size=num_employees),
    'JobSatisfaction': np.random.choice([1, 2, 3, 4], size=num_employees),
    'WillingnessToRelocate': np.random.choice([0, 1], size=num_employees)
})

# Step 2: Create target label: RelocationSuitability
conditions = (
    (data['WillingnessToRelocate'] == 1) &
    (data['JobSatisfaction'] <= 2) &
    (data['PerformanceRating'] >= 3)
)
data['RelocationSuitability'] = np.where(conditions, 1, 0)

# Step 3: Encode department
le = LabelEncoder()
data['DepartmentEncoded'] = le.fit_transform(data['Department'])

# Step 4: Train classifier to predict suitability
features = ['Age', 'YearsAtCompany', 'PerformanceRating', 'JobSatisfaction', 'WillingnessToRelocate', 'DepartmentEncoded']
target = 'RelocationSuitability'

X = data[features]
y = data[target]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)

# Evaluate model
y_pred = clf.predict(X_test)
print("Classification Report:\n", classification_report(y_test, y_pred))

# Step 5: Predict suitability for all employees
data['PredictedSuitability'] = clf.predict(X)

# Step 6: Simulate available job locations
num_locations = 20
locations = pd.DataFrame({
    'LocationID': range(1, num_locations + 1),
    'LocationName': [f"City_{i}" for i in range(1, num_locations + 1)],
    'Priority': np.random.randint(1, 5, size=num_locations)  # lower is better
})

# Step 7: Optimization using cost matrix (simple heuristic)
# Create a cost matrix where lower values are preferred
suitable_employees = data[data['PredictedSuitability'] == 1].reset_index(drop=True)
num_matches = min(len(suitable_employees), len(locations))
cost_matrix = np.zeros((num_matches, num_matches))

for i in range(num_matches):
    for j in range(num_matches):
        emp = suitable_employees.iloc[i]
        loc = locations.iloc[j]
        # Cost function: high performance and low job satisfaction are better
        cost = (
            -emp['PerformanceRating'] * 2 +  # want high performance
            emp['JobSatisfaction'] * 1.5 +  # want lower satisfaction
            loc['Priority']                 # location priority (lower is better)
        )
        cost_matrix[i][j] = cost

# Step 8: Solve assignment using Hungarian Algorithm
row_ind, col_ind = linear_sum_assignment(cost_matrix)

# Step 9: Print optimal assignments
print("\n Optimal Relocation Plan:")
for emp_idx, loc_idx in zip(row_ind, col_ind):
    emp = suitable_employees.iloc[emp_idx]
    loc = locations.iloc[loc_idx]
    print(f"Employee {emp['EmployeeID']} ➡️ {loc['LocationName']} (Priority: {loc['Priority']})")
